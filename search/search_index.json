{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome","text":"<p>Thuya CMS is an open-source, headless Content Management System based on NodeJS and Express.</p> <p></p>"},{"location":"#goals","title":"Goals","text":"<p>The goal of Thuya CMS is to simplify backend development. As a result, the target audience is software developers.</p> <p>With the help of Thuya, it is not required to:</p> <ul> <li>Write the same authorization or authentication logic again and again</li> <li>Create a database connection and implement the persistency just to store some simple data</li> <li>Pull large packages where your project uses only a little piece of it</li> <li>Read through lengthy documentation about the required JSON or YAML formats to define your content</li> </ul> <p>Tip</p> <p>Get started by getting familiar with the terminology.</p>"},{"location":"basics/extend/","title":"Extend","text":"<p>The Thuya CMS Framework only provides the base to manage content definitions, content field definitions and content. It does not provide any authentication or authorization logic and defines only a few content that is required by the framework to operate correctly. However it is possible to extend an application.</p>"},{"location":"basics/extend/#modules","title":"Modules","text":"<p>Extending an application can be achieved using modules. A module has a name and a version and can contain content providers and controllers to extend the application with additional content or logic.</p>"},{"location":"basics/extend/#content-providers","title":"Content providers","text":"<p>Content providers are used to serve data to the Thuya CMS. Data can be content definition, content field definition and initial content. </p> <p>It also support migration from an older module version to a new one. With each version content definitions, content field definitions and initial content can be created, updated and deleted. </p> <p>Warning</p> <p>Content definitions and content field definitions needs to be uniquely named among all modules used by an application. </p>"},{"location":"basics/extend/#controllers","title":"Controllers","text":"<p>Sometimes you do not want to define data as a content definition but extend the application with additional functions. Using controllers you can add any REST operation to the application. For example add an implementation to log in using a <code>POST</code> operation on path <code>/login</code>.</p>"},{"location":"basics/content-management/content-definition/","title":"Content definition","text":""},{"location":"basics/content-management/content-definition/#schema","title":"Schema","text":"<p>Content definitions have the following structure:</p> Name Type Optional Unique id string true true name string true contentFields array name string contentFieldDefinitionName string options isRequired boolean isUnique boolean isIndexed boolean"},{"location":"basics/content-management/content-definition/#contentfieldsname","title":"<code>contentFields.name</code>","text":"<p>It needs to be unique within a content definition.</p>"},{"location":"basics/content-management/content-definition/#contentfieldscontentfielddefinitionname","title":"<code>contentFields.contentFieldDefinitionName</code>","text":"<p>It needs to match the name of an existing content field definition.</p>"},{"location":"basics/content-management/content-definition/#operations","title":"Operations","text":""},{"location":"basics/content-management/content-definition/#read","title":"Read","text":""},{"location":"basics/content-management/content-definition/#by-name","title":"By name","text":"<p>Request: <code>GET &lt;host&gt;/content-definition/name/&lt;content definition name&gt;</code></p> <p>It will return a single content definition by name.</p>"},{"location":"basics/content-management/content-definition/#list","title":"List","text":"<p>Request: <code>GET &lt;host&gt;/content-definition</code></p> <p>It will return all content definitions.</p>"},{"location":"basics/content-management/content-definition/#create","title":"Create","text":"<p>Request: <code>POST &lt;host&gt;/content-definition</code></p> <p>It will create a new content definition. The body should contain the content definition data without the <code>id</code> field.</p> <p>Warning</p> <p>Before creating a content definition you should ensure that all content field definitions exist.</p>"},{"location":"basics/content-management/content-definition/#update","title":"Update","text":"<p>Request: <code>PATCH &lt;host&gt;/content-definition</code></p> <p>It will update an existing content definition. The body should contain the content definition data including the <code>id</code> field. The content should include all properties, delta update is not supported.</p> <p>Warning</p> <p>Before updating a content definition you should ensure that all content field definitions exist.</p>"},{"location":"basics/content-management/content-definition/#delete","title":"Delete","text":""},{"location":"basics/content-management/content-definition/#by-name_1","title":"By name","text":"<p>Request: <code>DELETE &lt;host&gt;/content-definition/name/&lt;content definition name&gt;</code></p> <p>It will delete an existing content definition by name. </p>"},{"location":"basics/content-management/content-field-definition/","title":"Content field definition","text":""},{"location":"basics/content-management/content-field-definition/#schema","title":"Schema","text":"<p>Content field definitions have the following structure:</p> Name Type Optional Unique id string true true name string true type enum arrayElementDefinitionName string true groupElements array true contentDefinitionName string name string options isRequired boolean"},{"location":"basics/content-management/content-field-definition/#type","title":"<code>type</code>","text":"<p>The following values are valid:</p> <ul> <li>\"numeric\"</li> <li>\"text\"</li> <li>\"date\"</li> <li>\"boolean\"</li> <li>\"array\"</li> <li>\"group\"</li> </ul>"},{"location":"basics/content-management/content-field-definition/#operations","title":"Operations","text":""},{"location":"basics/content-management/content-field-definition/#read","title":"Read","text":""},{"location":"basics/content-management/content-field-definition/#by-name","title":"By name","text":"<p>Request: <code>GET &lt;host&gt;/content-field-definition/name/&lt;content field definition name&gt;</code></p> <p>It will return a single content field definition by name.</p>"},{"location":"basics/content-management/content-field-definition/#list","title":"List","text":"<p>Request: <code>GET &lt;host&gt;/content-field-definition</code></p> <p>It will return all content field definitions.</p>"},{"location":"basics/content-management/content-field-definition/#create","title":"Create","text":"<p>Request: <code>POST &lt;host&gt;/content-field-definition</code></p> <p>It will create a new content field definition. The body should contain the content field definition data without the <code>id</code> field.</p>"},{"location":"basics/content-management/content-field-definition/#delete","title":"Delete","text":""},{"location":"basics/content-management/content-field-definition/#by-name_1","title":"By name","text":"<p>Request: <code>DELETE &lt;host&gt;/content-field-definition/name/&lt;content field definition name&gt;</code></p> <p>It will delete an existing content field definition by name. </p>"},{"location":"basics/content-management/content/","title":"Content","text":"<p>Note</p> <p>content definition is a prerequisite to create content.</p>"},{"location":"basics/content-management/content/#schema","title":"Schema","text":"<p>The schema of a content is dynamic and depends on the content definition.</p> Name Type Optional Unique Immutable id string true true true &lt;content fields&gt;"},{"location":"basics/content-management/content/#operations","title":"Operations","text":""},{"location":"basics/content-management/content/#read","title":"Read","text":""},{"location":"basics/content-management/content/#by-id","title":"By id","text":"<p>Request: <code>GET &lt;host&gt;/&lt;content-definition-name&gt;/&lt;id&gt;</code></p> <p>It will return a single content of a content definition by id.</p>"},{"location":"basics/content-management/content/#list","title":"List","text":"<p>Request: <code>GET &lt;host&gt;/&lt;content-definition-name&gt;</code></p> <p>It will return all content for the content definition.</p>"},{"location":"basics/content-management/content/#create","title":"Create","text":"<p>Request: <code>POST &lt;host&gt;/&lt;content-definition-name&gt;</code></p> <p>It will create new content based on the content definition. The body should contain the content data without the <code>id</code> field.</p>"},{"location":"basics/content-management/content/#update","title":"Update","text":"<p>Request: <code>PATCH &lt;host&gt;/&lt;content-definition-name&gt;</code></p> <p>It will update existing content based on the content definition. The body should contain the content data including the <code>id</code> field. The content should include all properties, delta update is not supported.</p>"},{"location":"basics/content-management/content/#delete","title":"Delete","text":""},{"location":"basics/content-management/content/#by-id_1","title":"By id","text":"<p>Request: <code>DELETE &lt;host&gt;/&lt;content-definition-name&gt;/&lt;id&gt;</code></p> <p>It will delete existing content by id. </p>"},{"location":"basics/content-management/introduction/","title":"Content management","text":"<p>Thuya is based on Express, so content can be managed using REST calls. The body of the calls is always expected to be valid JSON. You can manage the following objects:</p> <ul> <li>Content definitions</li> <li>Content field definitions</li> <li>Content</li> </ul> <p>While content definitions and content field definitions are always available on the same URL, the access to content depends on the name of the corresponding content definition. But let's take a look at the details starting with content definitions first.</p>"},{"location":"basics/terminology/content-definition/","title":"Content definition","text":"<p>Content Definition is the top level when you define content. It is the schema of an object that uses content fields to define its structure. Each content field has a name, a content field definition and additional options.</p> <p>Supported content field options are:</p> <ul> <li>required: cannot be saved without a value</li> <li>indexed: will be indexed in the database</li> <li>unique: cannot be saved if another content of the same content definition exists with the same value for this field</li> <li>immutable: a value can only be provided for create but cannot be changed afterwards</li> </ul> <p>Note</p> <p>Each content definition automatically contains an <code>id</code> content field. This field is unique and immutable.</p>"},{"location":"basics/terminology/content-definition/#example","title":"Example","text":"<p>The content definition for the example can be named <code>blog-post</code>. We can use the previously created content field definitions to add the required content fields. </p> Content definition Content field name Content field definition Options blog-post title common-text required, indexed content html-text publishAfter common-date required options blog-post-options isPublic common-boolean priority common-number tags common-text-array <p>For example one content field is <code>title</code>, using content field definition <code>common-text</code> and it is required. All other content fields need to be added using the previously created content field definitions. </p> <p>Now the the content definition is available we can create content matching it.</p>"},{"location":"basics/terminology/content-field-definition/","title":"Content field definition","text":"<p>A content field definition defines the type, validation rules, and determinations for properties. Each content field definition needs to have a unique name.</p> <p>The following type of content field definitions can be defined:</p> <ul> <li>Text</li> <li>Numeric</li> <li>Date</li> <li>Boolean</li> <li>Array</li> <li>Group</li> </ul> <p>Note</p> <p>Besides ensuring that the content will match the type these content field definitions will not validate anything additional. However new content field definitions can be created inheriting from any of these, containing more specific restrictions for the content.</p>"},{"location":"basics/terminology/content-field-definition/#types","title":"Types","text":""},{"location":"basics/terminology/content-field-definition/#text","title":"Text","text":"<p>Content field definition for simple text values. <code>Example: \"This a text.\"</code></p>"},{"location":"basics/terminology/content-field-definition/#numeric","title":"Numeric","text":"<p>Content field definition for simple numeric values. Only valid numbers are accepted. <code>Example: 10</code></p>"},{"location":"basics/terminology/content-field-definition/#date","title":"Date","text":"<p>Content field definition for simple date values. Only valid dates are accepted. <code>Example: \"2024-07-21T01:24:37.000Z\"</code></p>"},{"location":"basics/terminology/content-field-definition/#boolean","title":"Boolean","text":"<p>Content field definition for simple boolean values. Only valid boolean values are accepted. <code>Value set: true or false</code></p>"},{"location":"basics/terminology/content-field-definition/#array","title":"Array","text":"<p>Content field definition for an array of elements that are defined by another content field definition. For the elements content field definitions of any type are accepted. <code>Example: [\"blue\", \"green\", \"red\"]</code></p> <p>Tip</p> <p>Arrays can be nested in any depth with other arrays or groups.</p>"},{"location":"basics/terminology/content-field-definition/#group","title":"Group","text":"<p>Content field definition containing content fields, similar to content definitions. Sometimes we would like to define rules for not only a single value but for the value of multiple fields. For example, we would like to use date intervals in content. It is possible to do it by adding a <code>startDate</code> and an <code>endDate</code> field to the content definition and extend it with additional validations, that <code>startDate</code> is before the <code>endDate</code>. It can work. But the next time you would like to include a date range in another content definition you will need to implement the validation logic again. </p> <p>Instead, it is possible to use group content fields. In this case, the group would contain the <code>startDate</code> and <code>endDate</code> fields with the additional validation, that can be simply included in any content definition.</p> <p>Tip</p> <p>Groups can be nested in any depth with other groups or arrays.</p>"},{"location":"basics/terminology/content-field-definition/#example","title":"Example","text":"<pre><code>{\n\"title\": \"Thuya tutorial - Part 1\", // `common-text`\n\"content\": \"&lt;div&gt;The tutorial documentation is under development.&lt;/div&gt;\", // `html-text`\n\"publishAfter\": \"2024-07-21T01:24:37.000Z\", // `common-date`\n\"options\": { // `blog-post-options`\n\"isPublic\": true, // `common-boolean`\n\"priority\": 1 // `common-number`\n},\n\"tags\": [\"typescript\", \"tutorial\", \"cms\"] // `common-text-array` with `common-text` elements\n}\n</code></pre> <p><code>title</code> is a simple string without additional validations. For this, we need to create a content field definition with type text. Let's name it <code>common-text</code> as it doesn't contain any specifics.</p> <p>The <code>content</code> property contains HTML data. To be secure we need to validate the HTML before saving. so it requires a new content field definition with type text, containing additional validations to ensure that only strings containing valid HTML can be saved. It can be named <code>html-text</code>.</p> <p>The <code>publishAfter</code> field contains a date so a content field definition with type date is required. As it is also quite generic it can be named <code>common-date</code>.</p> <p>The <code>options</code> field is interesting as its value is an object and not a literal. So let's start again bottom up with its properties. <code>isPublic</code> needs a boolean while <code>priority</code> is a numeric content field definition. Both are generic so the names can be <code>common-boolean</code> and <code>common-number</code>. The <code>options</code> property is a content field definition of group type. A group will not directly have a value but can contain other fields. Groups can be nested in any depth, avoiding recursiveness. Its name can be for example <code>blog-post-options</code>.</p> <p><code>tags</code> contains an array of strings. It can use an array content field definition, for the element type reusing <code>common-text</code>. It can be called <code>common-text-array</code>.</p> <p>Now that all content fields have definitions let's take a look at the next level, content definitions.</p>"},{"location":"basics/terminology/content/","title":"Content","text":"<p>The content is the JSON/JavaScript data, matching and validated by the content definition. Whenever data is created or updated, Thuya will automatically load the corresponding content definition, remove all properties from the data that don't have a matching content field and, validate all values using the content field definitions. </p> <p>Note</p> <p>Content cannot be created without a matching content definition. </p>"},{"location":"basics/terminology/introduction/","title":"Terminology","text":"<p>With Thuya you can easily define \"structures\" that can be mapped to JSON objects. To do this you need to get familiar with the following terms:</p> <ul> <li>Content Field Definition</li> <li>Content Definition<ul> <li>Content Field</li> </ul> </li> <li>Content</li> </ul> <p>Let's start with an example. The following JSON contains the content of a blog post: </p> <pre><code>{\n\"title\": \"Thuya tutorial - Part 1\",\n\"content\": \"&lt;div&gt;The tutorial documentation is under development.&lt;/div&gt;\",\n\"publishAfter\": \"2024-07-21T01:24:37.000Z\",\n\"options\": {\n\"isPublic\": true,\n\"priority\": 1\n},\n\"tags\": [\"typescript\", \"tutorial\", \"cms\"]\n}\n</code></pre> <p>To handle this content in Thuya, we need to start bottom up, so let's check the properties first. For each property we need to define its type. In Thuya this is defined by content field definitions.</p>"},{"location":"core/common/","title":"Common","text":"<p>Note</p> <p>Coming soon...</p>"},{"location":"core/introduction/","title":"Introduction","text":"<p>Note</p> <p>Coming soon...</p>"},{"location":"core/auth/authentication/","title":"Authentication","text":"<p>Note</p> <p>Coming soon...</p>"},{"location":"core/auth/authorization/","title":"Authorization","text":"<p>Note</p> <p>Coming soon...</p>"},{"location":"development/content-definition/","title":"Content Definition","text":"<p>To create a new content definition, a class needs to be inherited from the content definition abstract class.</p> <p>Let's create a content definition that represents user login data. Assume that the required content field definitions already exist.</p> <pre><code>import { ContentDefinition } from '@thuya/framework';\nimport User from \"./types/user\";\nimport emailFieldDefinition from \"../content-field/email-content-field-definition\";\nimport passwordFieldDefinition from \"../content-field/password-content-field-definition\";\nclass UserContentDefinition extends ContentDefinition&lt;User&gt; {\nconstructor() {\nsuper(\"\", \"user\");\nthis.addContentField(\"email\", emailFieldDefinition, { isRequired: true, isUnique: true, isIndexed: true });\nthis.addContentField(\"password\", passwordFieldDefinition, { isRequired: true });\n}\n}\nexport default new UserContentDefinition();\n</code></pre> <p>With this content definition, we can simply create users, containing an email and a password field. With proper content field definitions, it is ensured that email is valid and the password meets the security requirements and is hashed.</p>"},{"location":"development/content-field-definition/","title":"Content Field Definition","text":"<p>To create a new content field definition, a class needs to be inherited from one of the type-specific classes:</p> <ul> <li>TextContentFieldDefinition</li> <li>NumericContentFieldDefinition</li> <li>BooleanContentFieldDefinition</li> <li>DateContentFieldDefinition</li> <li>ArrayContentFieldDefinition</li> <li>GroupContentFieldDefinition</li> </ul>"},{"location":"development/content-field-definition/#define-a-text","title":"Define a text","text":"<p>First, let's take a simple example of <code>TextContentFieldDefinition</code> to define a new content field definition for email addresses.</p> <pre><code>import { TextContentFieldDefinition, Result } from \"@thuya/framework\";\nclass EmailAddressContentFieldDefinition extends TextContentFieldDefinition {\nprotected filePath: string = __filename;\nconstructor() {\nsuper(\"\", \"email-address\");\nthis.addValidator(this.validateEmail);\nthis.addDetermination(this.convertToLowerCase);\n}\nprivate validateEmail(fieldValue: string): Result {\n// isValidEmail function is not implemented in the example.\nif (isValidEmail(fieldValue)) return Result.error(`Invalid email address.`);\nreturn Result.success();\n}\nprivate convertToLowerCase(fieldValue: string): string {\nreturn fieldValue.toLowerCase();\n}\n}\nexport default new EmailAddressContentFieldDefinition();\n</code></pre> <p>The above example will create a content field definition that will validate the input content to see if it is a valid email address. For valid input, it will convert the string to lowercase. It can be used in any content definition for email fields.</p> <p>All other simple types like numeric, date, and boolean can be defined the same way. Arrays and groups are a little more complex, so let's take a look at them as well.</p>"},{"location":"development/content-field-definition/#define-an-array","title":"Define an array","text":"<p>Let's assume we would like to collect the email address of users in a content, who are authorized to edit it. To achieve it we need an array of email addresses. Luckily we already have the content field definition for email addresses, so only the array content field definition is required.</p> <pre><code>import { ArrayContentFieldDefinition } from \"@thuya/framework\";\nimport { emailAddressContentFieldDefinition } from \"./email-address-content-field-definition\";\nclass EmailAddressesContentFieldDefinition extends ArrayContentFieldDefinition {\nconstructor() {\nsuper(\"\", \"email-addresses\", emailAddressContentFieldDefinition);\n}\n}\nexport default new EmailAddressesContentFieldDefinition();\n</code></pre> <p>And that's all. With this content field definition, we have an array of email addresses. All of the elements will be validated and converted to lowercase as defined in the email address content field definition.</p>"},{"location":"development/content-field-definition/#define-a-group","title":"Define a group","text":"<p>Date ranges are used frequently. You could define a simple data content field definition and them as a start date and an end date to each content definition, but you would need to implement interval validations in each content definition separately. That doesn't sound too good.</p> <p>Instead, we can create a content field definition that contains multiple fields. This is called a group. As it is a content field definition it can contain validations and determinations as usual, so the interval check can be implemented. Then this content field definition can be used in any content definition and it is guaranteed that the intervals are always valid.</p> <p>For simplicity reasons let's assume that content field definition for a simple date already exists.</p> <pre><code>import { GroupContentFieldDefinition, Result } from \"@thuya/framework\";\nimport { commonDateContentFieldDefinition } from \"./common-date-content-field-definition\";\ntype DateInterval = {\nstartDate: Date,\nendDate: Date\n}\nclass DateIntervalContentFieldDefinition extends GroupContentFieldDefinition&lt;DateInterval&gt; {\nprotected filePath: string = __filename;\nconstructor() {\nsuper(\"\", \"date-interval\");\nthis.addContentField(\"startDate\", commonDateContentFieldDefinition, { isRequired: true });\nthis.addContentField(\"endDate\", commonDateContentFieldDefinition, { isRequired: true });\nthis.addValidator(this.validateInterval);\n}\nprivate validateInterval(fieldValue: DateInterval): Result {\nif (fieldValue.endDate &lt; fieldValue.startDate)\nreturn Result.error(`Invalid date interval.`);\nreturn Result.success();\n}\n}\nexport default new DateIntervalContentFieldDefinition();\n</code></pre> <p>The above definition will validate if the start date is before the end date. When adding the content fields to the group it is also set that both fields are required, so it is not possible to create a date interval if any of its fields is missing.</p> <p>Nesting</p> <p>Groups and arrays can be nested in any depth. So arrays can contain groups or arrays and groups can also contain other groups or arrays.</p>"},{"location":"development/content-provider/","title":"Content Provider","text":"<p>In Thuya there are no strict requirements on where the files need to be located and what should be the name. You can place them wherever you want and use any name for content definitions and content field definitions. But somehow the framework needs to know that these exist. That's why we have content providers.</p> <p>To create a content provider a class has to extend the abstract <code>ContentProvider</code> class.</p> <pre><code>import { ContentDefinition, ContentFieldDefinition, ContentProvider } from \"@thuya/framework\";\nimport authRestrictionContentDefinition from \"./content-definition/auth-restriction-content-definition\";\nimport rolesContentFieldDefinition from \"./content-field/roles-content-field-definition\";\nimport operationsContentFieldDefinition from \"./content-field/operations-content-field-definition\";\nimport contentDefinitionNameContentFieldDefinition from \"./content-field/content-definition-name-content-field-definition\";\nclass AuthContentProvider extends ContentProvider {\noverride getContentFieldDefinitions(): ContentFieldDefinition[] {\nreturn [\nrolesContentFieldDefinition, operationsContentFieldDefinition,\ncontentDefinitionNameContentFieldDefinition\n];\n}\noverride getContentDefinitions(): ContentDefinition[] {\nreturn [authRestrictionContentDefinition];\n}\noverride async getInitialContent(): { contentDefinitionName: string, content: any }[] {\nreturn [{\ncontentDefinitionName: authRestrictionContentDefinition.getName(),\ncontent: {\ncontentDefinitionName: authRestrictionContentDefinition.getName(),\noperations: [\"POST\", \"GET\", \"PATCH\", \"DELETE\"],\nroles: [\"admin\"]\n}\n}, {\ncontentDefinitionName: authRestrictionContentDefinition.getName(),\ncontent: {\ncontentDefinitionName: userContentDefinition.getName(),\noperations: [\"POST\", \"GET\", \"PATCH\", \"DELETE\"],\nroles: [\"admin\"]\n}\n}];\n}\n}\nexport default new AuthContentProvider();\n</code></pre> <p>The above content provider returns content field definitions for roles, operations, and content definition names. It also returns a content definition for authorization restriction. Then the <code>getInitialContent</code> method defines authorization restrictions that should exist when the system starts, using the previously provided content definition.</p> <p>Note</p> <p>Content field definitions will not be extracted from content definitions. Each content field definition needs to be provided separately.</p>"},{"location":"development/content-provider/#migrations","title":"Migrations","text":"<p>Sometimes you would like to update content definitions, content field definitions, or initial content in a live application. This can be achieved using migrations. Let's enhance the previous example.</p> <pre><code>import { ContentDefinition, ContentFieldDefinition, ContentProvider, MigrationOperation } from \"@thuya/framework\";\nimport authRestrictionContentDefinition from \"./content-definition/auth-restriction-content-definition\";\nimport userContentDefinition from \"./content-definition/user-content-definition\";\nimport rolesContentFieldDefinition from \"./content-field/roles-content-field-definition\";\nimport operationsContentFieldDefinition from \"./content-field/operations-content-field-definition\";\nimport contentDefinitionNameContentFieldDefinition from \"./content-field/content-definition-name-content-field-definition\";\nimport emailAddressContentFieldDefinition from \"./content-field/email-address-content-field-definition\";\nclass AuthContentProvider extends ContentProvider {\noverride getContentFieldDefinitions(): ContentFieldDefinition[] {\nreturn [\nrolesContentFieldDefinition, operationsContentFieldDefinition,\ncontentDefinitionNameContentFieldDefinition,\nemailAddressContentFieldDefinition\n];\n}\noverride getContentDefinitions(): ContentDefinition[] {\nreturn [authRestrictionContentDefinition, userContentDefinition];\n}\noverride async getInitialContent(): { contentDefinitionName: string, content: any }[] {\nreturn [{\ncontentDefinitionName: authRestrictionContentDefinition.getName(),\ncontent: {\ncontentDefinitionName: authRestrictionContentDefinition.getName(),\noperations: [\"POST\", \"GET\", \"PATCH\", \"DELETE\"],\nroles: [\"admin\"]\n}\n}, {\ncontentDefinitionName: authRestrictionContentDefinition.getName(),\ncontent: {\ncontentDefinitionName: userContentDefinition.getName(),\noperations: [\"POST\", \"GET\", \"PATCH\", \"DELETE\"],\nroles: [\"admin\"]\n}\n}];\n}\noverride getContentFieldDefinitionMigrations(): { version: number, migration: { operation: MigrationOperation, contentFieldDefinition: ContentFieldDefinition }[] }[] {\nreturn [{\nversion: 2,\nmigration: [{\noperation: MigrationOperation.Created,\ncontentFieldDefinition: emailAddressContentFieldDefinition\n}]\n}];\n}\noverride getContentDefinitionMigrations(): { version: number, migration: { operation: MigrationOperation, contentDefinition: ContentDefinition }[] }[] {\nreturn [{\nversion: 2,\nmigration: [{\noperation: MigrationOperation.Created,\ncontentDefinition: userContentDefinition\n}]\n}];\n}\noverride getContentMigrations(): { version: number, migration: { operation: MigrationOperation, contentDefinitionName: string, content: any }[] }[] {\nreturn [{\nversion: 2,\nmigration: [{\noperation: MigrationOperation.Created,\ncontentDefinitionName: userContentDefinition.getName(),\ncontent: {\nemailAddress: \"admin@mydomain.com\"\n}\n}]\n}];\n}\n}\nexport default new AuthContentProvider();\n</code></pre> <p>The code above does the following:</p> <ul> <li>Creates new content field definition for email addresses.</li> <li>Creates new content definition for users.</li> <li>Creates new initial content for an admin user.</li> </ul> <p>Each migration contains version 2. Assuming that the initial version was 1, the framework will detect that a higher version is available and execute the steps.</p> <p>Warning</p> <p>The original data should always reflect the latest state of the application. In case of a new deployment as the metadata contains the latest version number the migrations will not be executed.</p>"},{"location":"development/controller/","title":"Controller","text":"<p>Controllers make it possible to define additional actions for your application using an Express router. Let's implement a simple controller that adds a <code>hello-world</code> route to our application. To do this we need a class that inherits from <code>IController</code>.</p> <pre><code>import { IController } from \"@thuya/framework\";\nimport { Request, Response, Router } from \"express\";\nclass HelloWorldController implements IController {\nprivate router: Router;\nconstructor() {\nthis.router = Router();\nthis.router.get(\"/hello-world\", this.helloWorld);\n}\ngetRouter(): Router {\nreturn this.router;\n}\nprivate helloWorld(request: Request, response: Response) {\nresponse.send(\"Hello world.\");\n}\n}\nexport default new HelloWorldController();\n</code></pre> <p>With this controller in place, if there is a <code>GET</code> call to the <code>/hello-world</code> URL of the application, the \"Hello world.\" text will be returned.</p>"},{"location":"development/module/","title":"Module","text":"<p>Extending the behavior of a Thuya application can be done using modules. Each module has metadata and can return content providers and controllers. A module can be created by extending the <code>Module</code> class.</p> <pre><code>import { ContentProvider, Module } from \"@thuya/framework\";\nimport authContentProvider from \"./auth-content-provider\";\nimport authController from \"./auth-controller\";\nclass AuthModule extends Module {\noverride getMetadata(): { name: string; } {\nreturn {\nname: \"auth-module\",\nversion: 1\n};\n}\noverride getContentProviders(): ContentProvider[] {\nreturn [commonContentProvider];\n}\noverride getControllers(): IController[] {\nreturn [authController];\n}\n}\nexport default new AuthModule();\n</code></pre> <p>The above example defines a module for authentication. It has metadata containing a name with the initial version. It has one content provider and one controller.</p> <p>The name of a module needs to be unique in a Thuya application. The version needs to be increased for migrations. In the content providers, it is possible to define migration steps that need to be in sync with the version defined in the manifest.</p> <p>Tip</p> <p>How the content providers and controllers are split is up to your design. Technically it is possible to place everything into one content provider or one controller, but you can also create dedicated ones.</p>"},{"location":"persistency/mongodb/","title":"MongoDB","text":"<p>Note</p> <p>Coming soon...</p>"}]}